{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Groot Engine","text":"<p>A small and simple Vulkan abstraction library meant to give access to GPU Rendering and Compute without any extra uneeded features of modern game engines.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple API - Small and straightforward to use.</li> <li>Resource Management - Automatic resource lifetime tracking through the use of a resource ID system</li> <li>Built in Abstractions - No need to bring in vulkan types as the library is entirely self contained</li> <li>GPU Memory Management - Uses AMD's Vulkan Memory Allocator to efficiently manage GPU memory </li> <li>Input System - Per-Frame tracked Keyboard and Mouse input state</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Rendering an Object</li> <li>Dispatching Compute Passes</li> <li>Keyboard and Mouse Input</li> </ul>"},{"location":"getting_started/compute/","title":"Dispatching Compute Passes","text":"<p>This section will cover dispatching compute shaders. If you haven't already, it is recommended to go through Rendering and Object first to get a fuller understanding of how Groot Engine works.</p> <p>Resources</p> <p>With every Groot Engine project, create an engine. Then use this engine to compile your shaders.</p> <pre><code>// main.cpp\n\n#include &lt;groot/groot.hpp&gt;\n\nusing namespace groot;\n\nint main() {\n  Engine engine;\n\n  RID comp_shader = engine.compile_shader(ShaderType::Compute, \"path/to/compute/shader\");\n  RID vert_shader = engine.compile_shader(ShaderType::Vertex, \"path/to/vertex/shader\");\n  RID frag_shader = engine.compile_shader(ShaderType::Fragment, \"path/to/fragment/shader\");\n}\n</code></pre> <p>Note that it might be best to check that these shaders are valid with the <code>RID::is_valid()</code> method, as if there are any compilation errors with your shaders the program will display the errors but not exit.</p> <p>Now lets create the storage texture. Storage textures are just textures that have 2 bindings. The first binding is for the UAV texture that you can read and write to. The second binding is for the sampler that can be read in the fragment shader. Groot Engine handles layout transitions of these images automatically so your storage textures are guaranteed to be in the correct layouts during your compute shader and your fragment shader.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID sampler = engine.create_sampler(SamplerSettings{});\n\n  auto [width, height] = engine.viewport_dims();\n  RID storage_texture = engine.create_storage_texture(width, height, sampler, Format::rgba16_sfloat);\n}\n</code></pre> <p>Now create a descriptor set that uses this storage texture.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID descriptor_set = engine.create_descriptor_set({ storage_texture });\n}\n</code></pre> <p>Now we have 2 pipelines to create: a compute pipeline and a graphics pipeline.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID compute_pipeline = engine.create_compute_pipeline(comp_shader, descriptor_set);\n  RID graphics_pipeline = engine.create_graphics_pipeline(GraphicsPipelineShaders{\n    .vertex   = vert_shader,\n    .fragment = frag_shader\n  }, descriptor_set, GraphicsPipelineSettings{\n    .cull_mode = CullMode::None\n  });\n}\n</code></pre> <p>For this example, we are creating a full screen triangle to display our compute shader output on. This is a standard practice for things like path tracers where the compute shaders do the rendering and you just need to display their output. For this reason, using no culling is fine since it doesnt matter which way the vertices are drawn.</p> <p>The next step is to load the triangle mesh, create an object from it, the graphics pipeline, and the descriptor set, and then add it to the scene.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID mesh = engine.load_mesh(\"path/to/obj/file\");\n\n  Object triangle;\n  triangle.set_mesh(mesh);\n  triangle.set_pipeline(graphics_pipeline);\n  triangle.set_descriptor_set(descriptor_set);\n\n  engine.add_to_scene(triangle);\n}\n</code></pre> <p>To dispatch the compute shader, you first create a compute command. Then, you tell the engine to dispatch all stored compute commands. For any commands that do not have barriers, they will be processed simultaneously, so make sure to specify that a barrier is needed if you have subsequent passes that depend on each other. After dispatching, run the engine and you should see a uv texture filling the whole viewport!</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n  engine.compute_command(ComputeCommand{\n    .pipeline       = compute_pipeline,\n    .descriptor_set = descriptor_set,\n    .work_groups    = { (width + 7) / 8, (height + 7) / 8, 1 }\n  });\n  engine.dispatch();\n\n  engine.run([&amp;engine](double) {\n    if (engine.just_pressed(Key::Escape))\n      engine.close_window();\n  });\n}\n</code></pre> <p>It is important to round up the thread count to make sure each thread gets one index in the output image. The formula for this is <code>(max_threads + local_threads - 1) / local_threads</code>. While this may produce a work group that goes over the thread count that you need, returning early in the compute shader if the thread index exceeds what you need makes it so that none of these extra threads actually get used.</p>"},{"location":"getting_started/graphics/","title":"Rendering an Object","text":"<p>This section will cover rendering an object with a texture on it. Tutorial resources are available below, but feel free to use your own obj file and image. Before starting, make sure to set up a C++ project to use CMake and confirm linking to Groot Engine works.</p> <p>Resources</p> <p>In your main.cpp file, include <code>groot/groot.hpp</code> add a new <code>Engine</code> object</p> <pre><code>// main.cpp\n\n#include &lt;groot/groot.hpp&gt;\n\nusing namespace groot;\n\nint main() {\n  Engine engine;\n}\n</code></pre> <p>The <code>Engine</code> object is your interface to the GPU. Everything you do in Groot Engine is controlled by this one class. It can be constructed with a <code>Settings</code> struct that allows you to specify different things like window size and whether to use VSync or not.</p> <p>Now create a new file called <code>shader.vert</code> and open it. This is the object's vertex shader that will run for every vertex specified in the mesh. In Groot Engine, vertices are defined by a <code>vec3</code> position, <code>vec2</code> UV coordinate, and <code>vec3</code> normal.</p> <p>If your obj file does not define UV's or normals, Groot Engine will generate them when loading the mesh</p> <p>Here is the base vertex shader. We will add to this later once the object is set up.</p> <pre><code>// shader.vert\n\n#version 460\n\nlayout(location = 0) in vec3 _VertexPosition;\nlayout(location = 1) in vec2 _VertexUV;\nlayout(location = 2) in vec3 _VertexNormal;\n\nlayout(location = 0) out vec2 _UV;\nlayout(location = 1) out vec3 _Normal;\n\nvoid main() {\n\n}\n</code></pre> <p>Now create a new file called <code>shader.frag</code> and open it. This will be the object's fragment shader which will run for every pixel mapped to by the rasterizer.</p> <p>If you do not know what the rasterizer is, please watch this video as you will learn quite a bit from it.</p> <p>Here is the base fragment shader. We will add to this later as well after setting the object up.</p> <pre><code>// shader.frag\n\n#version 460\n\nlayout(location = 0) in vec2 _UV;\nlayout(location = 1) in vec3 _Normal;\n\nlayout(location = 0) out vec4 _FragColor;\n\nvoid main() {\n\n}\n</code></pre> <p>Now back to <code>main.cpp</code>, we can add a compilation step for these shaders:</p> <pre><code>// main.cpp\n...\n\nint main() {\n  Engine engine;\n\n  RID vertex_shader = engine.compile_shader(ShaderType::Vertex, \"&lt;path/to/vertex/shader&gt;\");\n  RID fragment_shader = engine.compile_shader(ShaderType::Fragment, \"&lt;path/to/fragment/shader&gt;\");\n}\n</code></pre> <p>Note that it might be best to check that these shaders are valid with the <code>RID::is_valid()</code> method, as if there are any compilation errors with your shaders the program will display the errors but not exit.</p> <p>The <code>RID</code> object (\"resource ID\") is the base of Groot Engine's resource management system. Groot Engine owns all of the Vulkan resources that you create so that you don't have to mange them yourself. Holding on to the resource's <code>RID</code> allows you to communicate with the engine about when you want to use the resource, as well as simplifies the setup of using the same resource for multiple purposes (ie. sharing a buffer between two descriptor sets). If the engine ever fails to create a resource, the RID will be invalid and you will get a message in the console.</p> <p>Now, lets create a uniform buffer to keep track of the object's model matrix, camera view matrix, camera projection matrix, and the object's normal matrix</p> <pre><code>// main.cpp\n...\n\nstruct UniformBuffer {\n  mat4 model = mat4::identity();\n  mat4 view = mat4::identity();\n  mat4 proj = mat4::identity();\n  mat4 norm = mat4::identity();\n};\n\nint main() {\n  ...\n\n  RID uniform_buffer = engine.create_uniform_buffer(sizeof(UniformBuffer));\n}\n</code></pre> <p>Now that we have access to the transform matrices, we can update the vertex shader to use them</p> <pre><code>// shader.vert\n\nlayout(binding = 0) uniform transform {\n  mat4 _Model;\n  mat4 _View;\n  mat4 _Proj;\n  mat4 _Norm;\n};\n\n...\n\nvoid main() {\n  gl_Position = _Proj * _View * _Model * vec4(_VertexPosition, 1.0);\n  _UV = _VertexUV;\n  _Normal = normalize(mat3(_Norm) * _VertexNormal);\n}\n</code></pre> <p>Next, lets make a texture. In order to do this, we have to first create a sampler, and then use the sampler when creating the texture.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID sampler = engine.create_sampler(SamplerSettings{\n    // feel free to explore different sampler settings here!\n  });\n  RID texture = engine.create_texture(\"&lt;path/to/image&gt;\", sampler);\n}\n</code></pre> <p>Now, lets update the fragment shader to use the texture (and normals passed in from the vertex shader)</p> <pre><code>// shader.frag\n\nlayout(binding = 1) uniform sampler2D _Texture;\n\n...\n\nvoid main() {\n  _FragColor = texture(_Texture, _UV);\n}\n</code></pre> <p>Now the shaders are finished for this tutorial!</p> <p>The next step is to create the descriptor set that uses the uniform buffer and texture that were just made. Descriptor sets are just sets of buffers and images, or 'descriptors', that are pushed all at once to the GPU. It is more efficient to do it this way rather than sending the descriptors over one at a time.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID descriptor_set = engine.create_descriptor_set({ uniform_buffer, texture });\n}\n</code></pre> <p>Descriptor sets order their binding by the order of RID's that you submit to them. In this example, <code>uniform_buffer</code> has binding 0 and <code>texture</code> has binding 1.</p> <p>There are also storage texture resources which are textures that are sampled in the graphics pipeline but are also storage images in the compute pipeline. These take up 2 consecultive bindings. For example, if <code>texture</code> was a storage texture in the above example, it would use binding 1 in the compute shader and binding 2 in the fragment shader</p> <p>To full complete the graphics setup, we must create a graphics pipeline that uses the vertex and fragment shaders and the descriptor set</p> <pre><code>...\nint main() {\n  ...\n\n  RID pipeline = engine.create_graphics_pipeline(GraphicsPipelineShaders{\n    .vertex   = vertex_shader,\n    .fragment = fragment_shader\n  }, descriptor_set, GraphicsPipelineSettings{});\n}\n</code></pre> <p>I recommend using the default <code>GraphicsPipelineSettings</code> for now, but if you want to change some settings for future objects, that struct is where you would do it.</p> <p>Now load the mesh. Meshes are just a resource that keeps track of a vertex and index buffer retrieved from an obj file.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  RID mesh = engine.load_mesh(\"&lt;path/to/obj/file&gt;\");\n}\n</code></pre> <p>Using the mesh, descriptor set, and pipeline, you can create an <code>Object</code></p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  Object object;\n  object.set_mesh(mesh);\n  object.set_pipeline(pipeline);\n  object.set_descriptor_set(descriptor_set);\n}\n</code></pre> <p>Now add the object to the scene</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  engine.add_to_scene(object);\n}\n</code></pre> <p>Now we can run the engine and make the cube rotate while were at it! Feel free to keep track of the object's transform however you want, but Groot Engine provides a <code>Transform</code> struct that has methods to do this automatically.</p> <pre><code>// main.cpp\n...\nint main() {\n  ...\n\n  Transform transform;\n  UniformBuffer buffer{\n    .proj = engine.camera_projection()\n  };\n\n  engine.run([&amp;engine, &amp;uniform_buffer, &amp;transform, &amp;buffer](double dt) {\n    // add this to close out of the window by pressing escape\n    // If you are curious about checking for keyboard/mouse input, read through\n    // the 'input' section of Getting Started in the docs\n    if (engine.just_pressed(Key::Escape))\n      engine.close_window();\n\n    // rotate the cube at 10 radians a second\n    transform.rotation += radians(10.0) * dt;\n\n    buffer = UniformBuffer{\n      .model  = transform.matrix(),\n      .view   = engine.camera_view(),\n      .norm   = transform.matrix().inverse().transpose()\n    };\n\n    engine.write_buffer(uniform_buffer, buffer);\n  });\n}\n</code></pre> <p>The <code>run</code> method takes in a function that returns void and accepts a double argument. The engine passes in the frame time as a double argument.</p> <p>Now just build your target (make sure to link to Groot Engine) and run it and you'll see your object spinning in the scene!</p>"},{"location":"getting_started/input/","title":"Managing Input","text":"<p>Every piece of code here will be inside of <code>engine.run()</code>. If you do not know the syntax for this function, read through Rendering an Object or Dispatching Compute Passes first</p> <p>Groot Engine stores the current input state of the keyboard and mouse buttons as well as the input state of the current frame. You can query each state as follows:</p> <pre><code>// current frame input\nengine.just_pressed(Key / MouseButton);\nengine.just_released(Key / MouseButton);\n\n// current keyboard/mouse input\nengine.is_pressed(Key / MouseButton);\n</code></pre> <p>The frame input state is reset at the end of each frame so it is better to check the frame input state for responses that should happen quickly and responsively like toggles, and check the overall input state if the response can be held down or happen over multiple frames.</p> <p><code>Key</code> and <code>MouseButton</code> are both enums that are used to make accessing the input state more intuitive. For example, use <code>Key::W</code> to check if W is pressed or released. Similarly, use <code>MouseButton::Left</code> to check if the left mouse button is pressed or released.</p>"},{"location":"getting_started/installation/","title":"Groot Engine Installation","text":"<p>Groot Engine was configured using CMake and will assume you are using it as well to simplify things. If you are not using CMake, be sure to link to Vulkan, GLFW, ShaderC and its dependencies, and of course groot!</p> <p>Make sure you have the following dependencies installed:</p> <ul> <li>Vulkan</li> <li>GLFW</li> <li>ShaderC</li> <li>Catch2 (only if building tests)</li> </ul>"},{"location":"getting_started/installation/#building-and-installing","title":"Building and Installing","text":"<ol> <li> <p>Navigate to a directory you want groot engine to be in and clone the Groot Engine repository: <code>cd &lt;dir&gt; &amp;&amp; git clone https://github.com/groothipp/groot-engine.git</code></p> </li> <li> <p>Generate the makefiles with CMake: <code>cmake . -B build</code></p> <p>If you need <code>compile_commands.json</code> for your code intelligence, make sure to use <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code></p> </li> <li> <p>Compile Groot Engine: <code>cmake --build build</code></p> </li> <li> <p>Once Groot Engine is built install it to your system with: <code>cmake --install build</code></p> <p>If you want to change the install prefix from your native library and include directories, you can use <code>-DCMAKE_INSTALL_PREFIX=&lt;path/to/dir&gt;</code> during step 2</p> </li> </ol>"},{"location":"getting_started/installation/#using-groot-engine","title":"Using Groot Engine","text":"<p>Installing GrootEngine to your system allows CMake to find the package automatically. When setting up your CMakeLists.txt for your project, add the following:</p> <pre><code>find_package(GrootEngine REQUIRED)\n\ntarget_link_libraries(&lt;target_name&gt; PRIVATE GrootEngine::groot)\n</code></pre>"},{"location":"getting_started/installation/#uninstalling","title":"Uninstalling","text":"<p>Simply run the <code>uninstall.sh</code> script in the root of the Groot Engine repository if you installed it to your system. For custom install directories, you must delete the files yourself.</p>"}]}